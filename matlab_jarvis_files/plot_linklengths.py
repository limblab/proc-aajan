import numpy as np
import matplotlib.pyplot as plt

# return variables: fig, median errors
# input variables: path_GroundTruth, path_HybridNetPredictions
#  This takes the CSVs generated by Jarvis' built in analysis function and
#  gives the median Euclidean distance from ground truth for each keypoint
# 
#  Inputs:
#    path_GroundTruth - ie '/Users/ercrg/LimbLab/data/Pop_18E3/DPZ/models/hand23_br_100_split2/Validation_Predictions_20220501-204850/points_GroundTruth.csv')
#    path_HybridNetPredictioins - ie '/Users/ercrg/LimbLab/data/Pop_18E3/DPZ/models/hand23_br_100_split2/Validation_Predictions_20220501-204850/points_HybridNet.csv')
# 
#  This will probably be mostly called from the scatter_jarvis_errors script
#  eg
def get_linklengths(data_path):
	data = np.genfromtxt(data_path, delimiter=',')

	# set up landmarks
	pinky_t = np.array([1-1,2-1,3-1])
	pinky_d = np.array([4-1,5-1,6-1])
	pinky_m = np.array([7-1,8-1,9-1])
	pinky_p = np.array([10-1,11-1,12-1])

	ring_t = np.array([13-1,14-1,15-1])
	ring_d = np.array([16-1,17-1,18-1])
	ring_m = np.array([19-1,20-1,21-1])
	ring_p = np.array([22-1,23-1,24-1])

	middle_t = np.array([25-1,26-1,27-1])
	middle_d = np.array([28-1,29-1,30-1])
	middle_m = np.array([31-1,32-1,33-1])
	middle_p = np.array([34-1,35-1,36-1])

	index_t = np.array([37-1,38-1,39-1])
	index_d = np.array([40-1,41-1,42-1])
	index_m = np.array([43-1,44-1,45-1])
	index_p = np.array([46-1,47-1,48-1])

	thumb_t = np.array([49-1,50-1,51-1])
	thumb_d = np.array([52-1,53-1,54-1])
	thumb_m = np.array([55-1,56-1,57-1])
	thumb_p = np.array([58-1,59-1,60-1])

	palm = np.array([61-1,62-1,63-1])
	wrist_u = np.array([64-1,65-1,66-1])
	wrist_r = np.array([67-1,68-1,69-1])

	# set up differences
	pinky_td = np.zeros(data.shape[0])
	pinky_dm = np.zeros(data.shape[0])
	pinky_mp = np.zeros(data.shape[0])
	pinky_p_wrist = np.zeros(data.shape[0])

	ring_td = np.zeros(data.shape[0])
	ring_dm = np.zeros(data.shape[0])
	ring_mp = np.zeros(data.shape[0])
	ring_p_wrist = np.zeros(data.shape[0])

	middle_td = np.zeros(data.shape[0])
	middle_dm = np.zeros(data.shape[0])
	middle_mp = np.zeros(data.shape[0])
	middle_p_wrist = np.zeros(data.shape[0])

	index_td = np.zeros(data.shape[0])
	index_dm = np.zeros(data.shape[0])
	index_mp = np.zeros(data.shape[0])
	index_p_wrist = np.zeros(data.shape[0])

	thumb_td = np.zeros(data.shape[0])
	thumb_dm = np.zeros(data.shape[0])
	thumb_mp = np.zeros(data.shape[0])
	thumb_p_wrist = np.zeros(data.shape[0])

	for frame in range(data.shape[0]):
		# get Euclidian distance between each point
		pinky_td[frame] = np.linalg.norm(data[frame,pinky_t]-data[frame,pinky_d])
		pinky_dm[frame] = np.linalg.norm(data[frame,pinky_d]-data[frame,pinky_m])
		pinky_mp[frame] = np.linalg.norm(data[frame,pinky_m]-data[frame,pinky_p])
		pinky_p_wrist[frame] = np.linalg.norm(data[frame,wrist_r]-data[frame,pinky_p])

		ring_td[frame] = np.linalg.norm(data[frame,ring_t]-data[frame,ring_d])
		ring_dm[frame] = np.linalg.norm(data[frame,ring_d]-data[frame,ring_m])
		ring_mp[frame] = np.linalg.norm(data[frame,ring_m]-data[frame,ring_p])
		ring_p_wrist[frame] = np.linalg.norm(data[frame,wrist_r]-data[frame,ring_p])

		middle_td[frame] = np.linalg.norm(data[frame,middle_t]-data[frame,middle_d])
		middle_dm[frame] = np.linalg.norm(data[frame,middle_d]-data[frame,middle_m])
		middle_mp[frame] = np.linalg.norm(data[frame,middle_m]-data[frame,middle_p])
		middle_p_wrist[frame] = np.linalg.norm(data[frame,wrist_r]-data[frame,middle_p])

		index_td[frame] = np.linalg.norm(data[frame,index_t]-data[frame,index_d])
		index_dm[frame] = np.linalg.norm(data[frame,index_d]-data[frame,index_m])
		index_mp[frame] = np.linalg.norm(data[frame,index_m]-data[frame,index_p])
		index_p_wrist[frame] = np.linalg.norm(data[frame,wrist_r]-data[frame,index_p])

		thumb_td[frame] = np.linalg.norm(data[frame,thumb_t]-data[frame,thumb_d])
		thumb_dm[frame] = np.linalg.norm(data[frame,thumb_d]-data[frame,thumb_m])
		thumb_mp[frame] = np.linalg.norm(data[frame,thumb_m]-data[frame,thumb_p])
		thumb_p_wrist[frame] = np.linalg.norm(data[frame,wrist_r]-data[frame,thumb_p])

	linklengths = np.c_[pinky_td,pinky_dm,pinky_mp,pinky_p_wrist
						,ring_td,ring_dm,ring_mp,ring_p_wrist
						,middle_td,middle_dm,middle_mp,middle_p_wrist
						,index_td,index_dm,index_mp,index_p_wrist
						,thumb_td,thumb_dm,thumb_mp,thumb_p_wrist]
	linklengths = np.reshape(linklengths, (-1, 5, 4))
	return(linklengths)

def plot_linklengths(linklengths, date, bins = 400):
	titles = [['Pinky T - D','Pinky D - M','Pinky M - P','Pinky P - Wrist R'],
				['Ring T - D','Ring D - M','Ring M - P','Ring P - Wrist R'],
				['Middle T - D','Middle D - M','Middle M - P','Middle P - Wrist R'],
				['Index T - D','Index D - M','Index M - P','Index P - Wrist R'],
				['Thumb T - D','Thumb D - M','Thumb M - P','Thumb P - Wrist R']]
	lines = [[11.23,21.33,28.46,45.1],
				[15.21,20.75,36.22,45.51],
				[14.75,22.93,33.84,44.77],
				[11.48,19.28,32.16,44.36],
				[13.26,17.19,20.23,21.61]]
	fig, ax = plt.subplots(nrows = 5, ncols = 4)
	fig.set_size_inches(20, 20)
	fig.suptitle('Pop Linklengths - ' + date)
	for i in range(ax.shape[0]):
		for j in range(ax.shape[1]):
			ax[i][j].hist(linklengths[:,i,j], bins = bins)
			ax[i][j].axvline(lines[i][j], color ='red')
			ax[i][j].set_title(titles[i][j])
	plt.show()

def plot_superimposed_linklengths(linklengths1, linklengths2, date, labels, plot_percent = False, bins = 400):
	titles = [['Pinky T - D','Pinky D - M','Pinky M - P','Pinky P - Wrist R'],
				['Ring T - D','Ring D - M','Ring M - P','Ring P - Wrist R'],
				['Middle T - D','Middle D - M','Middle M - P','Middle P - Wrist R'],
				['Index T - D','Index D - M','Index M - P','Index P - Wrist R'],
				['Thumb T - D','Thumb D - M','Thumb M - P','Thumb P - Wrist R']]
	lines = [[11.23,21.33,28.46,45.1],
				[15.21,20.75,36.22,45.51],
				[14.75,22.93,33.84,44.77],
				[11.48,19.28,32.16,44.36],
				[13.26,17.19,20.23,21.61]]
	fig, ax = plt.subplots(nrows = 5, ncols = 4)
	fig.set_size_inches(20, 20)
	fig.suptitle('Pop Linklengths - ' + date)
	if plot_percent == False:
		fig.suptitle('Pop Linklengths - ' + date)
		for i in range(ax.shape[0]):
			for j in range(ax.shape[1]):
				ax[i][j].hist(linklengths1[:,i,j], bins = bins, alpha = 0.4, label = labels[0])
				ax[i][j].hist(linklengths2[:,i,j], bins = bins, alpha = 0.4, label = labels[1])
				ax[i][j].axvline(lines[i][j], color ='red')
				ax[i][j].set_title(titles[i][j])
				ax[i][j].legend()
	else:
		fig.suptitle('Pop Linklengths Percent Error - ' + date)
		for i in range(ax.shape[0]):
			for j in range(ax.shape[1]):
				ax[i][j].hist((linklengths1[:,i,j]-lines[i][j])/lines[i][j], bins = bins, alpha = 0.4, label = labels[0])
				ax[i][j].hist((linklengths2[:,i,j]-lines[i][j])/lines[i][j], bins = bins, alpha = 0.4, label = labels[1])
				# ax[i][j].axvline(lines[i][j], color ='red')
				ax[i][j].set_xlim([-1, 2])
				ax[i][j].set_title(titles[i][j])
				ax[i][j].legend()
	plt.show()

def get_full_with_half_max(linklenghts):
	return None
	